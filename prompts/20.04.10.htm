<html><head>
<title>INFO 3300 - April 10</title>

  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">

  <link rel="stylesheet" type="text/css" href="../css/normalize.css">
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/custom-style.css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>

  line.dashed {
    stroke: #aaa;
    stroke-width: 1px;
    stroke-dasharray: 2;
  }
  text.axis {
    text-anchor: end;
    font-variant: all-small-caps;
  }


  </style>
</head>

<body>
  <div class="container larger">
  <h3>Notes for April 10</h3>
  <p>Check out the documentation for <a href="https://github.com/d3/d3-force">d3.force</a> and the subsection for available <a href="https://github.com/d3/d3-force#forces">forces</a></p>
  <p>It turns out that d3 does not put every node at 0,0 directly if x and y are null. Instead, it staggers them using a <a href="https://observablehq.com/@mbostock/phyllotaxis">phyllotaxis arrangement</a>.</p>
  <p>Here is the d3.drag <a href="https://github.com/d3/d3-drag">documentation</a> and an <a href="https://bl.ocks.org/mbostock/3127661b6f13f9316be745e77fdfb084">example that combines drag and zoom</a>.</p>

  <h5>HTML for today:</h5>

  <svg id="graph" height="800" width="800" style="background: #sff; margin-top:50px" >
  </svg>
  <div>
  <button id="play">Play</button>
  <button id="stop">Stop</button>
  <button id="tick">Tick</button>
  </div>



  <h5>Code for today:</h5>
  <pre>
    <code id="display1" class="hljs javascript">
      <!--- autofilled --->
    </code>
  </pre>


  <script id="notes1">

  // Layer for drawing
  const layer = d3.select("#graph").append("g");
  const width = d3.select("#graph").attr("width");
  const height = d3.select("#graph").attr("height");
  const colorScale = d3.scaleOrdinal(d3.schemeSet1);


  const requestData = async () => {

    // Load dataset of CIS classes (note, I made this by hand so there probably will be tons of errors)
    const karate = await d3.json("../datasets/soc-karate.json");
    
    console.log(karate);

    //Assemble data structures for a graph
    var nodes = karate.nodes; // nodes can be just plain objects
    var links = karate.edges; // links should have source, target as sparse edge list
    
    // Positioning
    
    console.log(" Nodes and links before sim-start");
    console.log(nodes);
    console.log(links);

    // Build a simulation for the graph
  
  
  
  

    console.log(" Nodes and links after sim-start");
    console.log(nodes);
    console.log(links);



    
    







    
    // Handle the buttons provided in the HTML the same way as we did before
    d3.select("#play").on("click", () => {
      // Start animating the simulation
      sim.alpha(1).restart(); // clears the "alpha" value and starts fresh

    });
    d3.select("#stop").on("click", () => {
      // Pause the simulation animation
      sim.stop(); // pauses sim

    });
    d3.select("#tick").on("click", () => {
      // Move the simulation one "tick"
      sim.tick(); // moves one frame forward, but doesn't trigger tick event
      render(); // manually update circles

    });



  };

  requestData();



  </script>








  <!--- calls the highlight library to fill the <pre> tag with code --->
  <script>
  document.getElementById("display1").innerText = document.getElementById("notes1").innerText;
  hljs.initHighlightingOnLoad();
  </script>


  </div>
</body>
</html>
